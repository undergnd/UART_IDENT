Zadanie 1

Program wykrywa prędkość transmisji UART na podstawie odebranego bajtu i wykrywa, czy nadający moduł jest odsługiwany, po czym wysyła potwierdzenie (obsługiwany / nie obsługiwany) jeśli struktura bajtu powitalnego jest ok, w innym przypadku nie wysyła nic. 
Załączone pliki /log wyniki pomiarów.png, waveforms.png, logs_conf.png, waveforms_conf.png/ pokazują odbiór kodu "0xA3" z potwierdzeniem oraz odbiór przypadkowego znaku (pokazany impuls pomiarowy okresu bitu) dla każdej prędkości w zakeresie 9600 - 115200 bps. W teście zmieniałem prędkość nadawania w terminalu TeraTerm lub Putty i otrzymywałem odpowiedź z kontrolera ARM w wyliczonej prędkości UART takiej samej jak predkość nadawania terminali.
Krótki opis jak działa program. 
W funkcji main znajduje się pętla while która może być przerwana dynamicznym timeoutem. Timeout jest dynamiczny ponieważ jego wartość jest uaktualniana wraz ze znalezieniem czasu trwania bitu /wartość min_period_value/. W zależności od prędkości transmisji bity mają różną szerokość. Na podstawie pomiaru szerokości bitu odbiornik jest w stanie obliczyć prędkość transmisji /funkcja rekrut_update_com_speed/. Pomiar szerokości bitu dokonywany jest poprzez odczyt timera T1 pomiędzy dwoma kolejnymi zboczami sygnału. Ponieważ znamy również nachylenie zboczy /np.: int_edge = IRQ_EDGE_IS_SET_FALLING;/, możemy określić czy sygnał pomiędzy nimi to jedynki czy zera. Wszystkie czytane wartości są zapisywane do tablicy /struct Bits_s measurements[]/. 
Po przekroczeniu timeoutu następuje obliczenie poszczególnych bitów na podstawie zapisanych czasów trwania mierzonych odcinków pomiędzy zboczami /funkcja rekrut_stop_measurement/ i obliczana jest wartość bajtu. Obliczony bajt porównywany jest z bajtami powitalnymi obsługiwanych modułów i jeżeli następuje zgodność tych bajtów to jest odpowiedź pozytywna 0xAA. W innym wypadku jeżeli struktura bajtów powitalnego jest prawidłowa ale moduł nie jest obsługiwany udzielana jest odpowiedź 0xAF. Odpowiedź wysyłana jest z aktualną, obliczoną prędkością.
Program działa realnie, brakuje natomiast różnego rodzaju detekcji i zabezpieczeń przed błędami lub nieoczekiwanymi zdarzeniami w transmisji.

Zadanie 2 

Diagnostyka problemów z transmisją I2C. Jeśli jest to płytka z serii chciałbym wiedzieć, czy inne zachowują się podobnie, żeby określić czy jest to błąd systemowy (np w projekcie), czy pojedynczy na poszczególnej płytce. Na pewno należałoby obejrzec sygnały za pomocą oscyloskopu i analizatora stanów logicznych - w ten sposób można wychwycić problemy z impedancją (rezystancja, pojemność).
Jeśli błąd systemowy - podejrzenie błędu w projekcie: W pierwszej kolejności rzuca się w oczy wysoka wartość rezystorów podciągających 20 kohm. Tak więc pierwszą rzeczą w diagnostyce tych problemów jaką bym zrobił to wymiana rezystorów na odpowiednie, zgodne z dokumentacją /5 komów/. W przypadku gdyby to nie pomogło na pewno zapoznałbym się z dokumentacją wszystkich dołączonych urządzeń i sprawdził czy i w jaki sposób mają one wykonane interfejsy I2C i czy jest to odzwiercedlone na PCB. W przypadku nie znalezienia żadnych problemów w dokumentacji tych układów kolejną rzeczą jaką bym zrobił to odłączanie poszczególnych układów, żeby wyizolować układ który powoduje problemy. Gdyby to również nie pomogło kolejną rzeczą byłoby sprawdzenie oprogramowania mikrokontrolera. To sprawdzenie miałoby na celu znalezienie ewentualnych błędów w konfiguracji pinów na których działa I2C czyli na przykład czy nie występuje gdzieś jakaś dodatkowa konfiguracja która powoduje że właściwa konfiguracja jest zmieniona. Sprawdzenie oprogramowania można przeprowadzić wcześniej w zależności od jego skomplikowania - czasochłonności.
Jeśli błąd na pojedynczej płytce /pozostałe działąją ok - choc z tymi rezystorami byłoby to dziwne/ to pozostałaby diagnostyka połączeń na płytce i wymiana poszczególnych układów na inne egzemplarze plus sprawdzenie poprawności zaprogramowania kontrolera.

Zadanie 3

Bufor cykliczny 1 kB może przechować max 28 struktur o rozmiarze 36 B nie powodujac przepełnienia. Każdy następny zapis to przepełnienie bufora, czyli nadpisanie części danych. 
Ciągła praca bufora cyklicznego nawet przy prawidłowym jego odczytywaniu, czyli w okresach tak, aby nie powodować nadpisania danych to generacja kolejnych sum kontrolnych, które muszą być zapisywane w osobnej części flash. Brak informacji na temat organizacji tego zapisu. Jeśli jest to po prostu zapis kolejnych komórek/sektorów flash, bez mechanizmu zarządzania zapisywanym obszarem, łatwo może dojść do wykroczenia poza temn obszar i nadpisania innych danych. Ponadto również część flash staje się bezużyteczne, ponieważ po przepełnieniu bufora cyklicznego część zapisanych sum kontrolnych będzie się odnosić do już nie istniejących danych w buforze cyklicznym. Żeby zapewnić poprawną pracę należałoby sumy kontrolne również zapisywać w kolejce FIFO może również zorganizowanej w bufor cykliczny o takiej samej pojemności (czyli pierwszy bufor może zapisać 28 struktur, drugi 28 sum kontrolnych) i oba takie bufory wyposażyć w mechanizm zapobiegajacy nadpisywaniu danych lub co najmniej detekcję przepełnienia.
